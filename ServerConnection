
import java.net.DatagramPacket;
import java.util.ArrayList;
import java.util.Scanner;

public class ServerConnection {

	static ServerIO serverIO;
	boolean running = true;
	static String str;

	private static ArrayList<Player> players = new ArrayList<Player>(); // ArrayList of all the players
	private static Pile discardPile = new Pile(); // discard pile that holds all the cards after they are played
	private static Deck deck = new Deck(); // deck of cards (112 cards)
	private static int direction = 1; // 1 if forward, -1 if backwards
	private static int fancyIndex = 0; // index to decide the starting point when we hit the last player
	private static final int MAX_PLAYERS = 10; // number of max players
	private static Scanner s = new Scanner(System.in); // scanner for user input
	private static Card topCard; // the card that is in play
	private static ArrayList<Player> finishingOrder = new ArrayList<Player>(); // ArrayList of players when they finish
																				// in order
	private static int i = 0; // index to go through players

	public static void main(String args[]) throws Exception {
		int port = 0;
		System.out.print("Enter port number: ");
		port = s.nextInt();
		serverIO = new ServerIO(port);// new serverIO object

		initialize();
		str = "\nLets play UNO!\n\n" + "Deck: " + deck.getLength() + " Discard Pile: " + discardPile.getLength() + "\n";
		System.out.println(str);
		sendToAll();

		topCard = discardPile.getTop();
		boolean skipWasPlayed = false;

		while (players.size() > 1) // plays the game until only one player is left
		{
			for (i = fancyIndex; i < players.size() && i >= 0; i += direction)// outer loop to cycle between players
			{
				Player curPlayer = players.get(i);
				str = ("\n" + topCard + " is on top");
				sendToAll();
				System.out.println(str);

				str = (curPlayer + " is up");
				sendToAll();
				System.out.println(str);

				if (!curPlayer.getHand().hasNextPlay(topCard)) // if the player doesnt have a card he can play he draws
																// one
				{
					if (deck.isEmpty()) { // makes sure that the deck isnt empty
						switchPiles();
					}
					curPlayer.draw(deck.removeTop()); // player draws one card from the deck
					str = (curPlayer + " couldn't play so they drew a card");
					System.out.println(str);
					sendToAll();
					str = ("You drew " + curPlayer.getHand().getTop());
					sendToPlayer(curPlayer);
				}

				str = ("Your hand looks like: " + curPlayer.getHand().toString());
				sendToPlayer(curPlayer);
				System.out.println(str);

				if (curPlayer.getHand().hasNextPlay(topCard)) // asks the user which card they want to play and plays it
				{
					str = ("Card numbers " + getPlayableCardNums(curPlayer.getHand()) + " are playable.");
					sendToPlayer(curPlayer);
					System.out.println(str);

					int chosenCardNum = -2;
					boolean valid = false;
					do { // makes sure the player enters a valid card number or wants to skip
						str = ("Which card # do you want play? ");
						sendToPlayer(curPlayer);
						System.out.println(str);
						DatagramPacket packet = serverIO.getPacket();
						if (packet != null && packet.getPort() == curPlayer.getPort()) {
							String pktMsg = new String(packet.getData());
							pktMsg = pktMsg.substring(0, packet.getLength());
							try {
								chosenCardNum = Integer.parseInt(pktMsg);
								valid = true;
							} catch (NumberFormatException e) {
							}

							System.out.println(chosenCardNum);
							// if the card the client chose is not playable
							if (chosenCardNum != -1
									&& !getPlayableCardNums(curPlayer.getHand()).contains(chosenCardNum)) {
								str = ("Error: you chose a card # that can't be played.");
								System.out.println(str);
								sendToPlayer(curPlayer);
							}
						}
					} while ((chosenCardNum != -1 && !getPlayableCardNums(curPlayer.getHand()).contains(chosenCardNum))
							|| !valid);

					if (chosenCardNum == -1) // if player wants to skip they have to draw a card
					{
						curPlayer.draw(deck.removeTop());
						str = (curPlayer + " passed so they drew a card");// + curPlayer.getHand().getTop());
						System.out.println(str);
						sendToAll();
						str = ("You drew " + curPlayer.getHand().getTop());
						sendToPlayer(curPlayer);
					} else // plays the chosen card by the player
					{
						Card chosenCard = curPlayer.getHand().getCard(chosenCardNum);
						str = (curPlayer + " played " + chosenCard);
						sendToAll();

						discardPile.addToTop(curPlayer.getHand().remove(chosenCardNum));
						topCard = discardPile.getTop();

						if (chosenCard.isWild()) // if the card is wild it calls the appropriate method
						{
							switch (chosenCard.getCardValue()) {
							case REVERSE:
								reverse();
								break;
							case WILD:
								changeColor();
								break;
							case PLUS_FOUR:
								changeColor();
								draw(4, chosenCard);
								break;
							case PLUS_TWO:
								draw(2, chosenCard);
								break;
							case SWITCH_HANDS:
								if (curPlayer.getHand().isEmpty()) {
									changeColor();
								} else {
									swapHands();
								}
								break;
							case SKIP:
								getNextPlayerIndex();
								str = (players.get(i) + " was skipped");
								System.out.println(str);
								sendToAll();
								skipWasPlayed = true;
								break;
							default:
								break;
							}// end switch
						} // end wildCard if
					} // end else
				} // end of the huge if

				// checks if the player has only one card left
				if (curPlayer.checkUno()) {
					str = (curPlayer.getName() + " says UNO!");
					sendToAll();
				}

				if (curPlayer.getHand().isEmpty()) // if the player has won/finished
				{
					finishingOrder.add(players.remove(players.indexOf(curPlayer)));

					if (i >= players.size()) { // makes sure when the player wins it doesnt skip anyone
						i = players.size() - 1;
					}
					i -= direction < 0 ? 0 : skipWasPlayed && i == 0 ? 0 : 1; // makes sure that if the leaving player
																				// plays skip it fixes the next players
																				// position

					str = ("****" + curPlayer + " finished " + placeSuffix(finishingOrder.size()) + "!****\n");
					System.out.println(str);
					sendToAll();
					fancyIndex -= fancyIndex == 0 ? 0 : 1; // updates the fancyIndex so the order remains the same

					if (players.size() == 1) { // breaks out of the game once only one playeer is left
						finishingOrder.add(players.get(0));
						break;
					}
				}
				skipWasPlayed = false;
			} // end huge for loop
		} // end while

		s.close();

		// Print out the final standings to each client and the server console
		str = ("\n\nFinal Standings:");
		System.out.println(str);
		sendToAll();
		str = ("-------------------");
		System.out.println(str);
		sendToAll();

		for (int place = 1; place <= finishingOrder.size(); place++) {
			str = (place + ". " + finishingOrder.get(place - 1));
			System.out.println(str);
			sendToAll();
		}
		str = ("-------------------");
		System.out.println(str);
		sendToAll();

		str = "false";
		sendToAll();

	}

	private static String placeSuffix(int place) {
		String str = "";
		switch (place) {
		case 1:
			str = "1st";
			break;
		case 2:
			str = "2nd";
			break;
		case 3:
			str = "3rd";
			break;
		default:
			str = place + "th";
			break;
		}
		return str;
	}

	private static void reverse() {
		direction *= -1; // switches the driection
		switch (fancyIndex) // switches the fancy index
		{
		case 0:
			fancyIndex = players.size() - 1;
			break;
		default:
			fancyIndex = 0;
			break;
		}

	}

	private static void draw(int count, Card card) {
		getNextPlayerIndex();
		Player p = players.get(i);
		boolean canStack = false;
		int j = 0;
		if (card.compareValue(new Card(CardColor.BLACK, CardValue.PLUS_TWO)) == 0) // makes sure the card being played
																					// is plus_two
		{
			for (j = 0; j < p.getHand().getLength(); j++) // checks if the next player has a plus_two card
			{
				Card c = p.getHand().getCard(j);
				if (c.compareValue(new Card(CardColor.BLACK, CardValue.PLUS_TWO)) == 0) {
					canStack = true;
					break;
				}
			}
		}

		if (canStack) // if the next player has a plus_two card recall the method
		{
			str = (p + "stacked a PLUS_TWO on top.");
			System.out.println(str);
			sendToAll();
			discardPile.addToTop(p.getHand().remove(j));
			topCard = discardPile.getTop();
			draw(count + 2, card);
		} else // else give the next player the amount of cards they need
		{
			str = (p + " drew " + count + " cards.");
			System.out.println(str);
			sendToAll();
			for (int k = 0; k < count; k++) // gives the player their cards
			{
				if (deck.isEmpty()) { // makes sure the deck isnt empty
					switchPiles();
				}
				str = ("[" + deck.getTop() + "] ");
				System.out.println(str);
				sendToPlayer(p);
				p.draw(deck.removeTop());
			}
			System.out.println();
		}

	}

	private static void changeColor() {
		str = ("You played a wild card.");
		System.out.println(str);
		sendToPlayer(players.get(i));
		String color = "BLACK";

		do { // prompts current player to enter the color
			str = ("What color do you choose? (R,B,Y,G): ");
			sendToPlayer(players.get(i));

			DatagramPacket packet = serverIO.getPacket();
			if (packet != null && packet.getPort() == players.get(i).getPort()) {// if the packet is not empty and the
																					// port matches the player's port
				String pktMsg = new String(packet.getData());
				pktMsg = pktMsg.substring(0, packet.getLength());
				System.out.println(pktMsg);
				color = pktMsg.toLowerCase();
				System.out.print(color);
			}

			if (!color.equals("r") && !color.equals("b") && !color.equals("y") && !color.equals("g")) {// if the color
																										// they entered
																										// does not
																										// match r, b,
																										// y, or g
				System.out.print("That is an invalid color.");
			}
		} while (!color.equals("r") && !color.equals("b") && !color.equals("y") && !color.equals("g"));

		switch (color) // makes the top card the color chosen by current player
		{
		case "r":
			topCard = new Card(CardColor.RED, CardValue.WILD);
			break;
		case "b":
			topCard = new Card(CardColor.BLUE, CardValue.WILD);
			break;
		case "y":
			topCard = new Card(CardColor.YELLOW, CardValue.WILD);
			break;
		case "g":
			topCard = new Card(CardColor.GREEN, CardValue.WILD);
			break;
		}
		str = players.get(i) + " changed the color to " + topCard.getCardColor();
		System.out.println(str);
		sendToAll();
	}

	private static void swapHands() {
		int playerNum = -1;
		str = ("Players: ");
		sendToPlayer(players.get(i));

		for (int x = 0; x < players.size(); x++) // prints out the players the vurrentPlayer can switch hands with
		{
			if (!(x == i)) {
				str = ("[(" + x + ") " + players.get(x) + "] ");
				sendToPlayer(players.get(i));
			}
		}
		System.out.println();
		do { // asks the current player who they want to switch hands with
			str = ("Which Player do you want to swap hands with? (Enter Player #): ");
			sendToPlayer(players.get(i));

			DatagramPacket packet = serverIO.getPacket();
			if (packet != null && packet.getPort() == players.get(i).getPort()) {// if the packet is not empty and the
																					// ports match
				String pktMsg = new String(packet.getData());
				pktMsg = pktMsg.substring(0, packet.getLength());
				playerNum = Integer.parseInt(pktMsg);
				if (playerNum == i || playerNum < 0 || playerNum > players.size() - 1) {
					str = ("Error: Invalid player.");
					sendToPlayer(players.get(i));
				}
			}
		} while (playerNum == i || playerNum < 0 || playerNum > players.size() - 1);

		str = players.get(i) + " switched hands with " + players.get(playerNum);
		System.out.println(str);
		sendToAll();

		Hand tempHand = players.get(i).getHand();
		players.get(i).switchHand(players.get(playerNum).getHand());// giving current player the other player's hand
		players.get(playerNum).switchHand(tempHand);// giving the other player the current players hand
		changeColor(); // playing as wild card after switching

	}

	private static void getNextPlayerIndex() {
		i = getNextI();

	}

	private static int getNextI() {
		return (i + direction % players.size() == -1 ? players.size() - 1 : (i + direction) % players.size());
	}

	private static ArrayList<Integer> getPlayableCardNums(Hand playerHand) {
		ArrayList<Integer> playableCards = new ArrayList<>();

		for (int i = 0; i < playerHand.getLength(); i++) {
			if (playerHand.getCard(i).compareTo(topCard) == 0
					|| playerHand.getCard(i).getCardColor() == CardColor.BLACK) {
				playableCards.add(i);
			}
		}
		final Card PLUS_FOUR = new Card(CardColor.BLACK, CardValue.PLUS_FOUR);
		while (playableCards.size() > 1 && playerHand.search(PLUS_FOUR)
				&& playableCards.contains(Integer.valueOf(playerHand.getIndex(PLUS_FOUR)))) {

			playableCards.remove(Integer.valueOf(playerHand.getIndex(PLUS_FOUR)));
		}
		return playableCards;
	}

	private static void switchPiles() {
		for (int i = 0; i < discardPile.getLength(); i++) {
			deck.add(discardPile.remove(i));
		}
		deck.shuffle();

	}

	private static void sendToAll() {
		for (int k = 0; k < players.size(); k++) {
			serverIO.sendPacket(new DatagramPacket(str.getBytes(), str.getBytes().length, players.get(k).getIpAddress(),
					players.get(k).getPort()));
		}
		for (int k = 0; k < finishingOrder.size(); k++) {
			serverIO.sendPacket(new DatagramPacket(str.getBytes(), str.getBytes().length,
					finishingOrder.get(k).getIpAddress(), finishingOrder.get(k).getPort()));
		}

	}

	private static void sendToPlayer(Player curPlayer) {
		serverIO.sendPacket(new DatagramPacket(str.getBytes(), str.getBytes().length, curPlayer.getIpAddress(),
				curPlayer.getPort()));

	}

	private static void initialize() {
		int playerCount;
		do { // gets the number of players
			System.out.print("Enter the number of players: ");
			playerCount = s.nextInt();
			if (playerCount > MAX_PLAYERS || playerCount < 2) {
				System.out.println("Error: can only have between 2-" + MAX_PLAYERS + " players");
			}
		} while (playerCount > MAX_PLAYERS || playerCount < 2);
		System.out.println("Waiting for players.");

		ArrayList<Hand> playerHands = deck.deal(playerCount); // deals the hands to player
		System.out.println();

		System.out.println("Waiting for players to join.");
		int countdown = playerCount;

		while (countdown > 0) {// while all the players have yet to join
			DatagramPacket packet = serverIO.getPacket();
			if (packet != null) {
				String pktMsg = new String(packet.getData());
				pktMsg = pktMsg.substring(0, packet.getLength());
				if (pktMsg.toLowerCase().equals("join")) {
					String result = "Please enter your username.";
					serverIO.sendPacket(new DatagramPacket(result.getBytes(), result.getBytes().length,
							packet.getAddress(), packet.getPort()));
				} else if (pktMsg.contains("name: ")) {// if the client sends a packet "name: <name of player>"
					String result = "true";
					serverIO.sendPacket(new DatagramPacket(result.getBytes(), result.getBytes().length,
							packet.getAddress(), packet.getPort()));
					String playerName = pktMsg.substring(pktMsg.indexOf(':') + 1, pktMsg.length());
					System.out.println(playerName + " Joined the game.");
					players.add(new Player(packet.getAddress(), packet.getPort(), playerName,
							playerHands.get(countdown - 1)));// add that player to the players array
					countdown--;// subtract the countdown by one

				} else {
					String result = ": ";
					serverIO.sendPacket(new DatagramPacket(result.getBytes(), result.getBytes().length,
							packet.getAddress(), packet.getPort()));
				}
			}
		}
		str = "Everyone has joined the game. Starting game.";
		sendToAll();

		System.out.println("\nPlayers: ");
		for (int k = 0; k < players.size(); k++) {
			System.out.println(players.get(k).toString());
		}

		Card c = deck.removeTop();
		while (c.isWild()) // making sure the first card isn't wild
		{
			deck.add(c);
			c = deck.removeTop();
		}

		discardPile.add(c);// turns up top card of deck to begin game
	}
}
